<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Character – 프로필</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">

  <!-- ✅ 위치 데이터 공통 스크립트 추가 -->
  <script src="js/world-data.js"></script>

  <style>
    :root{
      --bg:#0f0f12;
      --panel:#18181f;
      --panel2:#121219;
      --text:#E8E6E3;
      --muted:#b7b3ad;
      --gold:#d4af37;
      --gold2:#b8922b;
      --card:rgba(212,175,55,.35)
    }

    *{
      box-sizing:border-box
    }

    body{
      margin:0;
      background:radial-gradient(1000px 600px at 70% -20%,rgba(212,175,55,.18),transparent 60%),radial-gradient(800px 600px at 0% 10%,rgba(125,106,61,.16),transparent 60%),#050507;
      color:var(--text);
      font-family:'Noto Sans KR',system-ui,sans-serif
    }

    a{color:inherit;
      text-decoration:none
    }

    header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:14px 16px;
      border-bottom:1px solid rgba(255,255,255,.08)
    }

    .btn{
      padding:8px 12px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.04);
      cursor:pointer
    }

    .btn.gold{
      background:linear-gradient(180deg,var(--gold),var(--gold2));
      color:#111;border:none
    }

    .wrap{
      display:grid;
      grid-template-columns:320px 1fr 260px;
      gap:16px;
      padding:16px
    }

    .card{
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border-radius:16px;
      border:1px solid rgba(255,255,255,.06);
      padding:14px 16px
    }

    .avatar{
      width:100%;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:#111;
      object-fit:cover;
      max-height:520px
    }

    .title{
      margin:0;
      font-size:1.8rem
    }

    .sub{
      margin-top:4px;color:var(--muted);
      font-size:.95rem
    }

    .kv{
      display:flex;
      justify-content:space-between;
      margin:4px 0;
      font-size:.95rem
    }

    .kv span{
      color:var(--muted)
    }

    .stat-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin:12px 0 8px
    }

    .radarWrap{
      display:flex;
      gap:16px;
      align-items:flex-start;
      flex-wrap:wrap
    }

    .radar{
      width:340px;
      height:260px;
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      background:#0d0f14;
      display:flex;
      align-items:center;
      justify-content:center
    }

    .radar svg{
      width:92%;
      height:92%
    }

    .legend{
      display:grid;
      grid-template-columns:repeat(2,minmax(140px,1fr));
      gap:6px;
      min-width:260px
    }

    .bar{
      height:12px;
      background:#0d0f14;
      border:1px solid rgba(255,255,255,.08);
      border-radius:99px;
      overflow:hidden
    }

    .bar>span{
      display:block;
      height:100%;
      background:linear-gradient(90deg,var(--gold),var(--gold2))
    }

    .statrow{
      display:grid;
      grid-template-columns:110px minmax(0,1fr) 70px;
      align-items:center;
      gap:8px;margin:6px 0;
      font-size:.9rem
    }

    .statrow>span:first-child{
      white-space:nowrap
    }

    .delta{
      font-size:.8rem;
      text-align:right
    }

    .equip{
      margin-top:10px;
      font-size:.95rem
    }

    .equip h3{
      margin:0 0 6px;
      font-size:1rem
    }

    .equip-row{
      display:flex;
      justify-content:space-between;
      margin:3px 0
    }

    .equip-row span:first-child{
      color:var(--muted)
    }

    .timeline{
      font-size:.9rem;
      color:var(--muted);
      margin-top:8px;
      max-height:220px;
      overflow:auto
    }

    .timeline-entry{
      margin-bottom:6px
    }

    .timeline-entry strong{
      color:var(--text)
    }

    .skills{
      font-size:.9rem;
      margin-top:10px
    }

    .skills h3{
      margin:0 0 6px;
      font-size:1rem
    }

    .group{
      margin-bottom:10px
    }

    .gtitle{
      margin:0 0 4px;
      font-size:.9rem;
      color:var(--muted)
    }

    .plist{
      display:flex;
      flex-wrap:wrap;
      gap:6px
    }

    .pill{
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      padding:4px 8px;
      font-size:.8rem;
      background:rgba(255,255,255,.02)
    }

    .pill .tag{
      font-size:.75rem;color:var(--muted);
      margin-left:4px
    }

    .small{
      font-size:.9rem;color:var(--muted)
    }

    .tag{
      font-size:.8rem;color:var(--muted)
    }
    .badge{
      display:inline-block;
      min-width:26px;
      text-align:center;
      font-size:.7rem;
      border-radius:6px;
      padding:1px 6px;
      margin-left:6px;
      color:#e9e1c9
    }
    .badge[data-rank="EX"], .badge[data-rank^="S"]{background:rgba(212,175,55,.18)}
    .badge[data-rank^="A"]{background:rgba(102,187,106,.18)}
    .badge[data-rank^="B"]{background:rgba(100,181,246,.18)}
    .badge[data-rank^="C"]{background:rgba(255,202,40,.12)}
    .badge[data-rank^="D"]{background:rgba(239,83,80,.12)}
    .badge[data-rank^="F"]{background:rgba(176,190,197,.18);color:#e0e6e9}

    ul{margin:0;padding-left:18px}

    .charSwitchItem{
      width:70px;
      text-align:center;
      cursor:pointer;
      flex-shrink:0;
    }

    .charSwitchItem img{
      width:70px;
      height:70px;
      border-radius:50%;
      object-fit:cover;
      border:2px solid transparent;
      transition: .15s;
    }

    .charSwitchItem span{
      display:block;
      margin-top:4px;
      font-size:.78rem;
      color:var(--muted);
    }

    .charSwitchItem.active img{
      border-color:var(--gold);
      box-shadow:0 0 6px rgba(212,175,55,.45);
    }
  </style>
</head>
<body>
  <header>
    <strong style="font-family:'Cinzel',serif;letter-spacing:.06em">CHARACTER</strong>
    <div>
      <a class="btn" href="index.html">← 메인</a>
      <a class="btn" href="member.html">멤버 관리</a>
    </div>
  </header>

  <div class="wrap">
    <!-- LEFT: Portrait & Basic -->
    <section class="card">
      <img id="cImg" class="avatar" alt="portrait">
      <div style="margin-top:10px">
        <div class="kv"><span>역할</span><strong id="cRole">-</strong></div>
        <div class="kv"><span>소속</span><div id="cSub" class="small">-</div></div>
      </div>
    </section>

    <!-- CENTER: Stats & Skills -->
    <section class="card">
      <h2 class="title" id="cName">캐릭터</h2>
      <div class="sub" id="cNote" style="margin-bottom:4px"></div>

      <!-- ✅ 추가: 현재 위치 표시 영역 -->
      <div class="sub" id="cLocation" style="margin-bottom:8px; color:var(--muted);"></div>

      <div class="stat-header"><h3 style="margin:0">스탯</h3><button id="chartToggle" class="btn">방사형 보기</button></div>
      <div id="statsBox"></div>
      <div class="small" id="statsHelp">기본치 + (직업, 특성/숙련도/권능의 ±, % 보정) = 최종치</div>

      <h3 style="margin:16px 0 8px">스킬/특성</h3>
      <div id="skillWrap" class="skills"></div>

      <!-- ▼ 캐릭터 전환 바 -->
      <div id="charSwitch" style="margin-top:20px; padding-top:16px; border-top:1px solid rgba(255,255,255,.08);">
        <h4 style="margin:0 0 10px; font-size:1rem;">캐릭터 전환</h4>
        <div id="charSwitchList" 
            style="display:flex; gap:14px; overflow-x:auto; padding-bottom:10px;">
        </div>
      </div>
      <!-- ▲ 캐릭터 전환 바 -->
    </section>

    <!-- RIGHT: Equip & Timeline -->
    <aside class="card">
      <div class="equip">
        <h3>장비</h3>
        <div class="equip-row"><span>장갑</span><span id="eqGlove">-</span></div>
        <div class="equip-row"><span>바지</span><span id="eqPants">-</span></div>
        <div class="equip-row"><span>셔츠</span><span id="eqShirt">-</span></div>
        <div class="equip-row"><span>신발</span><span id="eqBoots">-</span></div>
        <div class="equip-row"><span>무기</span><span id="eqWeapon">-</span></div>
      </div>

      <div class="timeline">
        <h3 style="margin:12px 0 6px;font-size:1rem">타임라인</h3>
        <div id="timelineBox"></div>
      </div>
    </aside>
  </div>

  <script> 
    /* =========================================================
     *  상수 / 공통 설정
     * ======================================================= */

    // localStorage 키
    const STORE='members.v1';            // 멤버 리스트
    const REP='representativeId';        // 대표 캐릭터 id
    const CODEX='codex.v1';              // 도감 데이터 (특성/숙련도/권능/스킬 등)
    const CMODE='chartMode.v1';          // 스탯 차트 모드 저장용

    // 도감 type → 한글 라벨
    const TYPE_LABELS={
      trait:'특성',
      tech:'기술',
      magic:'마법',
      skill:'스킬',
      authority:'권능',
      blessing:'가호',
      proficiency:'숙련도'
    };

    // 항상 스탯에 상시로 적용되는 타입 (전투 여부와 무관)
    const ALWAYS_ON_TYPES = new Set(['trait','proficiency','authority']);

// ==== 직업 정의 (jobId 기반) ====
    const JOB_DEFS = {
      none: {
        id: 'job_none',
        name: '무직',
        stat: { str:0, end:0, agi:0, int:0, mana:0, luck:0 },
        resource: 'mana',
        hidden: false
      },
      warrior: {
        id: 'job_warrior',
        name: '전사',
        stat: { str:3, end:2, agi:0, int:0, mana:0, luck:0 },
        resource: 'mana',
        hidden: false
      },
      archer: {
        id: 'job_archer',
        name: '궁수',
        stat: { str:1, end:0, agi:3, int:0, mana:0, luck:0 },
        resource: 'mana',
        hidden: false
      },
      assassin: {
        id: 'job_assassin',
        name: '암살자',
        stat: { str:1, end:0, agi:4, int:0, mana:0, luck:0 },
        resource: 'mana',
        hidden: false
      },
      mage: {
        id: 'job_mage',
        name: '마법사',
        stat: { str:0, end:0, agi:0, int:4, mana:3, luck:0 },
        resource: 'mana',
        hidden: false
      },
      priest: {
        id: 'job_priest',
        name: '성직자',
        stat: { str:0, end:1, agi:0, int:3, mana:3, luck:0 },
        resource: 'holy',   // ★ 성직자는 신성력 자원 사용
        hidden: false
      },
      // 예시 히든 직업 (원하는 만큼 추가 가능)
      hiddenSaint: {
        id: 'job_hidden_saint',
        name: '성자의 대리자',
        stat: { str:2, end:3, agi:1, int:4, mana:5, luck:2 },
        resource: 'holy',
        hidden: true
      }
    };

    const JOB_BY_NAME = {};
    const JOB_BY_ID   = {};
    Object.values(JOB_DEFS).forEach(j => {
      JOB_BY_NAME[j.name] = j;
      JOB_BY_ID[j.id]     = j;
    });

    function getJobForCharacter(ch) {
      if (ch.jobId && JOB_BY_ID[ch.jobId]) return JOB_BY_ID[ch.jobId];
      if (ch.role && JOB_BY_NAME[ch.role]) return JOB_BY_NAME[ch.role];
      return JOB_DEFS.none;
    }

    // 등급 정렬 기준 (앞에 있을수록 높은 등급)
    const RANK_ORDER=[
      "EX","SSS","SS","S+","S",
      "A++","A+","A","A-",
      "B++","B+","B","B-",
      "C++","C+","C-",
      "D++","D+","D","D-",
      "F++","F+","F","F-"
    ];

    // 등급 → 인덱스 (숫자가 작을수록 높은 등급, 못 찾으면 999)
    const rankIndex=r=>{
      const i=RANK_ORDER.indexOf(r||'');
      return i<0?999:i;
    };

    // 최종 스탯값 기준 등급 스케일
    const GRADE_SCALE=[
      {min:5000, rank:'EX'},
      {min:2000, rank:'SSS'},
      {min:600,  rank:'SS'},
      {min:580,  rank:'S+'},
      {min:400,  rank:'S'},
      {min:390,  rank:'A++'},
      {min:300,  rank:'A+'},
      {min:200,  rank:'A'},
      {min:190,  rank:'B++'},
      {min:150,  rank:'B+'},
      {min:70,   rank:'B'},
      {min:65,   rank:'C+'},
      {min:50,   rank:'C'},
      {min:45,   rank:'D+'},
      {min:20,   rank:'D'},
      {min:0,    rank:'F'}
    ];

    // 숫자 → 등급 문자열
    const gradeFor = v => {
      for(const g of GRADE_SCALE){
        if((v||0) >= g.min) return g.rank
      }
      return 'F'
    };

    // querySelector 단축 함수
    const $=s=>document.querySelector(s);

    /* =========================================================
     *  공통 유틸 함수
     * ======================================================= */

    // URL에서 쿼리 파라미터 가져오기 (?id=xxxx)
    function getParam(name){
      const u=new URL(location.href);
      return u.searchParams.get(name)
    }

    // localStorage 에서 멤버 목록 불러오기
    function loadMembers(){
      try{
        return JSON.parse(localStorage.getItem(STORE)||'[]')
      }catch{
        return []
      }
    }

    // localStorage 에서 도감 데이터 불러오기
    function loadCodex(){
      try{
        return JSON.parse(localStorage.getItem(CODEX)||'[]')
      }catch{
        return []
      }
    }

    // 현재 화면에 표시할 캐릭터 선택
    // 1순위: URL의 id, 2순위: 대표 캐릭터, 3순위: 리스트의 첫 번째
    function pickCharacter(list){
      const byId = getParam('id');
      if(byId){
        return list.find(x=>x.id===byId) || list[0]
      }
      const rep = localStorage.getItem(REP);
      if(rep){
        return list.find(x=>x.id===rep) || list[0]
      }
      return list[0];
    }

    /* =========================================================
     *  스탯 행(막대형) DOM 생성
     * ======================================================= */

    /**
     * 한 줄짜리 스탯(막대 bar) DOM 생성
     * @param {string} label - 스탯 이름 (근력 / 내구 등)
     * @param {number} base  - 기본치
     * @param {number} delta - 변화량(특성/숙련도/권능 보정 합)
     * @param {number} maxRef - 막대 길이 계산용 기준값
     * @param {string} tooltip - 마우스 오버 시 툴팁 내용
     */
    function statRow(label, base, delta, maxRef, tooltip){
      const row=document.createElement('div');
      row.className='statrow';

      const final = (base||0) + (delta||0);        // 최종치
      const grade = gradeFor(final);               // 최종치 등급
      const maxVal = Math.max(                    // 막대 최대 기준값
        1,
        maxRef||final,
        base,
        final,
        (base||0)+Math.abs(delta||0)
      );
      const signed = delta
        ? (delta>0?`+${delta}`:`${delta}`)
        : '';

      row.innerHTML = `
        <span>${label} [${grade}]</span>
        <div class='bar'>
          <span style='width:${Math.min(100,(final/maxVal)*100)}%'></span>
        </div>
        <div class='delta'>
          ${final}
          ${signed
            ? ` <span style='color:${delta>0?'#7ce085':'#f48fb1'}'>(${signed})</span>`
            : ''}
        </div>
      `;

      // 스탯 이름 위에 툴팁 달기 (특성/숙련도/권능 기여 내역)
      if (tooltip){
        const nameSpan = row.querySelector('span');
        if (nameSpan) nameSpan.title = tooltip;
      }
      return row;
    }

    /* =========================================================
     *  도감 기반 스킬/특성 스탯 보정 수집
     *  - member에서 선택한 스킬/특성들을 도감과 매칭
     *  - 상시 적용 타입(ALWAYS_ON_TYPES)만 스탯에 반영
     * ======================================================= */

    /**
     * member 에서 선택된 스킬/특성들을 분석해
     * 각 스탯별 보정값(flat, %)과 출처 목록을 반환
     *
     * 반환 형태:
     * {
     *   flat: {str,end,agi,int,mana,luck},
     *   pct:  {str,end,agi,int,mana,luck},
     *   sources: [
     *     {
     *       name, type, rank, tags,
     *       contrib: {
     *         str:{flat,pct}, ... (해당 스탯에 기여하는 값만)
     *       }
     *     }, ...
     *   ]
     * }
     */
    function collectSkillMods(ch){
      const codex = loadCodex();

      // ch.skills 항목 정규화
      // - 문자열: "이름"만 있는 옛 형식
      // - 객체: { name, rank, type, codexId } 새 형식
      const entries = (ch.skills || [])
        .map(s => {
          if (!s) return null;

          // 옛 데이터: 단순 문자열
          if (typeof s === 'string') {
            return { name: s, rank: null, type: null, codexId: null };
          }

          // 새 데이터: 객체 형태
          if (typeof s === 'object') {
            return {
              name:    s.name    || '',
              rank:    s.rank    || null,
              type:    s.type    || null,
              codexId: s.codexId || null
            };
          }
          return null;
        })
        .filter(e => e && e.name);

      // 누적용 스탯
      const flat  = {str:0,end:0,agi:0,int:0,mana:0,luck:0};  // 고정값
      const pct   = {str:0,end:0,agi:0,int:0,mana:0,luck:0};  // % 보정
      const sources = []; // 각 특성이 어느 스탯에 어떻게 기여했는지 기록

      entries.forEach(entry => {
        const nameLower   = entry.name.toLowerCase();
        const desiredRank = entry.rank    || null;   // member에서 선택한 등급
        const codexId     = entry.codexId || null;   // 고유 id

        let picked = null;

        // 1) codexId가 있으면: 그 id와 일치하는 특성/숙련도/권능 항목 하나만 사용
        if (codexId) {
          picked = codex.find(e =>
            ALWAYS_ON_TYPES.has(e.type) &&
            e.id === codexId
          ) || null;
        }

        // 2) codexId로 못 찾았거나 codexId가 없으면: 이름 기반으로 탐색
        if (!picked) {
          const candidates = codex.filter(e =>
            ALWAYS_ON_TYPES.has(e.type) &&
            (e.name || '').toLowerCase() === nameLower
          );
          if (!candidates.length) return;

          if (desiredRank) {
            // member에서 저장한 등급과 정확히 일치하는 항목 우선
            picked = candidates.find(e => (e.rank || '') === desiredRank) || null;

            // 등급이 바뀌었거나 못 찾으면 → 기존처럼 "가장 높은 등급"으로 폴백
            if (!picked) {
              picked = candidates
                .slice()
                .sort((a,b) => rankIndex(a.rank) - rankIndex(b.rank))[0];
            }
          } else {
            // 옛 데이터(등급 정보 없음)는 기존 동작 유지: 같은 이름 중 최고 등급
            picked = candidates
              .slice()
              .sort((a,b) => rankIndex(a.rank) - rankIndex(b.rank))[0];
          }
        }

        // 도감에서 매칭되는 항목이 없으면 건너뜀
        if (!picked) return;

        const m = picked.mod  || {};   // 고정 보정값
        const p = picked.modP || {};   // % 보정값

        // 이 특성이 기여한 스탯만 담는 객체
        const c = {};

        // 도감의 키를 캐릭터 스탯 키로 매핑해서 재계산
        function add(key, flatVal, pctVal){
          const f  = +(flatVal || 0);
          const pc = +(pctVal  || 0);
          if (!f && !pc) return;
          c[key] = {flat:f, pct:pc}; // 출처별 기록
          flat[key] += f;            // 전체 누적
          pct[key]  += pc;           // 전체 누적(%)
        }

        // 도감 내부 키(atk/def/spd/hp 등)를 캐릭터 스탯 키(str/end/agi/mana…)로 매핑
        add('str',  m.str  ?? m.atk,  p.str  ?? p.atk);
        add('end',  m.end  ?? m.def,  p.end  ?? p.def);
        add('agi',  m.agi  ?? m.spd,  p.agi  ?? p.spd);
        add('int',  m.int,            p.int);
        add('mana', m.mana ?? m.hp,   p.mana ?? p.hp);
        add('luck', m.luck,           p.luck);

        // 실제로 기여한 스탯이 하나라도 있다면 출처 목록에 추가
        if (Object.keys(c).length){
          sources.push({
            name: picked.name || '',
            type: picked.type || '',
            rank: picked.rank || '',
            tags: picked.tags || '',
            contrib: c
          });
        }
      });

      return {flat, pct, sources};
    }

    /* =========================================================
     *  직업(Job) 기반 스탯 보정
     *  - 각 캐릭터는 jobId 로 1개 직업만 가진다고 가정
     *  - 직업은 고정값(flat) 위주, 필요하면 %보정도 확장 가능
     * ======================================================= */
    function collectJobMods(ch){
      const job = getJobForCharacter(ch);
      const flat    = {str:0,end:0,agi:0,int:0,mana:0,luck:0};
      const pct     = {str:0,end:0,agi:0,int:0,mana:0,luck:0};
      const sources = [];

      if (!job || !job.stat){
        return { flat, pct, sources };
      }

      const s = job.stat;
      const contrib = {};

      function add(key, flatVal, pctVal){
        const f  = +(flatVal || 0);
        const pc = +(pctVal  || 0);
        if (!f && !pc) return;
        flat[key] += f;
        pct[key]  += pc;
        contrib[key] = { flat:f, pct:pc };
      }

      add('str',  s.str,  s.strP);
      add('end',  s.end,  s.endP);
      add('agi',  s.agi,  s.agiP);
      add('int',  s.int,  s.intP);
      add('mana', s.mana, s.manaP);
      add('luck', s.luck, s.luckP);

      if (Object.keys(contrib).length){
        sources.push({
          name: job.name,
          type: 'job',
          rank: '',
          tags: job.hidden ? '히든 직업' : '직업',
          contrib
        });
      }

      return { flat, pct, sources };
    }    

    /* =========================================================
     *  메인 렌더 함수
     *  - 캐릭터 정보 / 장비 / 타임라인 / 스탯 / 스킬 그룹 출력
     * ======================================================= */

    function render(){
      const list = loadMembers();
      if(!list.length){
        alert('멤버 데이터가 없습니다. member.html에서 캐릭터를 먼저 생성하세요.');
        return;
      }

      const ch = pickCharacter(list);

      /* -------- 기본 정보 출력 -------- */
      $('#cName').textContent = ch.name||'무명';
      $('#cNote').textContent = ch.note||'';
      $('#cRole').textContent = ch.role||'-';
      $('#cSub').textContent  = ch.sub||'-';
      $('#cImg').src = ch.img||'https://via.placeholder.com/420x560/1d1f26/777?text=NO+IMAGE';

      // ★ 현재 위치 표시
      const locEl = document.getElementById('cLocation');
      if (locEl) {
        try {
          locEl.textContent = makeLocationLabel(ch.position || null);
        } catch (e) {
          console.error('위치 표시 오류:', e);
          locEl.textContent = '현재 위치: 알 수 없음';
        }
      }

      /* -------- 장비 정보 출력 -------- */
      const eq = ch.equip||{};
      ['Glove','Pants','Shirt','Boots','Weapon'].forEach(k=>{
        const el=$('#eq'+k);
        el.textContent = eq[k.toLowerCase()]||'-'
      });

      /* -------- 타임라인 출력 -------- */
      const tl = ch.timeline||[];
      const tbox=$('#timelineBox');
      tbox.innerHTML='';

      if(!tl.length){
        tbox.innerHTML='<div class="timeline-entry">(기록 없음)</div>';
      }else{
        tl.sort((a,b)=> (a.year||0)-(b.year||0) );
        tl.forEach(e=>{
          const div=document.createElement('div');
          div.className='timeline-entry';
          div.innerHTML = `<strong>${e.year??''}</strong> ${e.text??''}`;
          tbox.appendChild(div);
        });
      }

      /* -------- 스탯 계산 준비 -------- */

      const base = ch.stats||{};          // 기본 스탯
      const mods = collectSkillMods(ch);  // 도감 기반 보정값
      const job  = getJobForCharacter(ch); // ★ 직업 정보

      // ★ 직업에 따라 자원 라벨 변경 (성직자 / 히든 성직 계열 → 신성력)
      const resourceLabel =
        job && job.resource === 'holy'
          ? '신성력'
          : '마나/내력';

      // 화면에 표시할 스탯 정의
      const statDefs = [
        {label:'근력',   key:'str'},
        {label:'내구',   key:'end'},
        {label:'민첩',   key:'agi'},
        {label:'지력',   key:'int'},
        {label:resourceLabel, key:'mana'},
        {label:'행운',   key:'luck'}
      ];

      // ★ 직업 보정 값 수집
      const jobMods = collectJobMods(ch);

      // 각 스탯별 최종 값 계산
      const data = statDefs.map(({label,key:k})=>{
        const dFlat   = (mods.flat[k] || 0) + (jobMods.flat[k] || 0); // 특성 + 직업 고정값
        const dPct    = (mods.pct[k]  || 0) + (jobMods.pct[k]  || 0); // 특성 + 직업 %보정
        const baseVal = base[k] || 0;                                  // 기본치
        const delta   = dFlat + Math.round(baseVal * (dPct/100));      // 총 변화량
        const final   = baseVal + delta;                               // 최종치
        return {
          label,
          key:k,
          base: baseVal,
          delta,
          final,
          grade: gradeFor(final)
        };
      });

      const maxFinal = Math.max(...data.map(d=>d.final), 1); // 그래프 스케일 기준

      /* -------- 스탯별 툴팁 텍스트 생성 -------- */

      const tooltipMap = {};
      data.forEach(d=>{
        const skillSources = (mods.sources    || []).filter(s => s.contrib && s.contrib[d.key]);
        const jobSources   = (jobMods.sources || []).filter(s => s.contrib && s.contrib[d.key]);
        const hasAny       = skillSources.length || jobSources.length;

        const lines = [];
        lines.push(`기본치: ${d.base}`);

        if (!hasAny){
          lines.push('(이 스탯에는 현재 보정이 적용되지 않습니다.)');
          tooltipMap[d.key] = lines.join('\n');
          return;
        }

        // 특성/숙련도/권능
        skillSources.forEach(s=>{
          const c = s.contrib[d.key];
          const typeLabel = TYPE_LABELS[s.type] || s.type || '기타';
          const rankText  = s.rank ? ` [${s.rank}]` : '';

          const parts = [];
          if (c.flat){
            parts.push(`${c.flat>0?'+':''}${c.flat}`);
          }
          if (c.pct){
            parts.push(`${c.pct>0?'+':''}${c.pct}%`);
          }
          lines.push(`${typeLabel} ${s.name}${rankText}: ${parts.join(', ')}`);
        });

        // 직업
        jobSources.forEach(s=>{
          const c = s.contrib[d.key];
          const parts = [];
          if (c.flat){
            parts.push(`${c.flat>0?'+':''}${c.flat}`);
          }
          if (c.pct){
            parts.push(`${c.pct>0?'+':''}${c.pct}%`);
          }
          lines.push(`직업 ${s.name}: ${parts.join(', ')}`);
        });

        tooltipMap[d.key] = lines.join('\n');
      });

      /* -------- 스탯 박스 렌더링 (막대형 / 레이더 차트) -------- */

      const box=$('#statsBox');
      box.innerHTML='';

      if(window.chartMode==='radar'){
        // 방사형(레이더) 차트
        box.appendChild(renderRadar(data, maxFinal, tooltipMap));
      }else{
        // 막대형 리스트
        data.forEach(d=> box.appendChild(
          statRow(d.label, d.base, d.delta, maxFinal, tooltipMap[d.key])
        ));
      }

      /* -------- 스킬/특성 리스트 그룹 출력 -------- */

      const codex = loadCodex();

      // id 와 이름 둘 다 인덱싱해 둔다
      const codexById   = new Map(codex.map(x => [x.id, x]));
      const codexByName = new Map(codex.map(x => [((x.name || '') + '').toLowerCase(), x]));

      // 화면에서 보일 그룹 섹션 정의
      const sections = [
        {title:'특성',             types:['trait']},
        {title:'숙련도',           types:['proficiency']},
        {title:'기술/마법/스킬',   types:['tech','magic','skill']},
        {title:'가호/권능',        types:['blessing','authority']}
      ];

      // 섹션별 그룹 초기화 (Map: 섹션 제목 → 배열)
      const grouped = new Map(sections.map(s => [s.title, []]));

      // ch.skills 에서 도감 항목 찾아 그룹에 채우기
      (ch.skills || []).forEach(s => {
        let entry = null;
        let plainName = '';

        if (typeof s === 'string') {
          // 옛 데이터: 이름만 문자열로 저장된 경우
          plainName = s;
          const key = s.toLowerCase();
          entry = codexByName.get(key) || null;

        } else if (s && typeof s === 'object') {
          // 새 데이터: { name, rank, type, codexId }
          plainName = s.name || '';

          // codexId 우선 매칭
          if (s.codexId && codexById.has(s.codexId)) {
            entry = codexById.get(s.codexId);
          } else {
            // codexId가 없으면 이름으로 매칭
            const key = (s.name || '').toLowerCase();
            entry = codexByName.get(key) || null;
          }
        }

        // 도감에서 못 찾은 항목은 "기술/마법/스킬" 그룹에 이름만 표시
        if (!entry) {
          (grouped.get('기술/마법/스킬') || []).push({ name: plainName });
          return;
        }

        const sec = sections.find(sec => sec.types.includes(entry.type));
        const keyTitle = sec ? sec.title : '기술/마법/스킬';
        (grouped.get(keyTitle) || []).push(entry);
      });

      // 실제 DOM에 출력
      const skillWrap = $('#skillWrap');
      skillWrap.innerHTML = '';

      sections.forEach(sec => {
        const arr = grouped.get(sec.title) || [];
        if (!arr.length) return;

        const box = document.createElement('div');
        box.className = 'group';
        box.innerHTML = `
          <h4 class='gtitle'>${sec.title}</h4>
          <div class='plist'></div>
        `;
        const plist = box.querySelector('.plist');

        arr.forEach(x => {
          const pill = document.createElement('span');
          pill.className = 'pill';

          if (x.type) {
            // 도감에 존재하는 항목: 등급 배지 + 타입/태그 표시
            pill.innerHTML =
              `<span>${x.name}` +
              `${x.rank ? ` <span class="badge" data-rank="${x.rank}">${x.rank}</span>` : ''}` +
              `</span><span class="tag">` +
              `${TYPE_LABELS[x.type] || x.type}` +
              `${x.tags ? ` · ${x.tags}` : ''}</span>`;
          } else {
            // 도감에 없는 이름만 있는 항목
            pill.textContent = x.name || '';
          }
          plist.appendChild(pill);
        });

        skillWrap.appendChild(box);
      });
      /* -------- 스킬/특성 렌더 끝 -------- */

      // ▼ 캐릭터 전환 바 렌더링
      renderCharacterSwitcher(ch.id);
    }

    /* -----------------------------------------
      * 캐릭터 전환 바 렌더링
      * ----------------------------------------- */
      function renderCharacterSwitcher(currentId){
        const list = loadMembers();
        const box  = document.getElementById("charSwitchList");
        if(!box) return;

        box.innerHTML = "";

        list.forEach(ch=>{
          const item = document.createElement("div");
          item.className = "charSwitchItem";
          if(ch.id === currentId) item.classList.add("active");

          item.innerHTML = `
            <img src="${ch.img || 'https://via.placeholder.com/100x100/1d1f26/777?text=NO'}">
            <span>${ch.name || '무명'}</span>
          `;

          item.onclick = () => {
            // 현재 페이지에서 다른 캐릭터로 이동
            location.href = `character.html?id=${ch.id}`;
          };

          box.appendChild(item);
        });
      }

    /* =========================================================
     *  차트 모드(막대형 / 방사형) 설정 및 토글 버튼
     * ======================================================= */

    // 차트 모드 초기값 (localStorage → 'bar' 또는 'radar')
    try{
      window.chartMode = localStorage.getItem(CMODE) || 'bar';
    }catch(e){
      window.chartMode = 'bar';
    }

    const chartToggleBtn = document.getElementById('chartToggle');

    // 버튼 라벨을 현재 모드에 맞게 갱신
    function updateChartToggleLabel(){
      if(!chartToggleBtn) return;
      chartToggleBtn.textContent =
        (window.chartMode === 'radar')
          ? '막대형 보기'
          : '방사형 보기';
    }

    // 버튼 클릭 시 모드 토글 + 렌더링
    if(chartToggleBtn){
      chartToggleBtn.addEventListener('click', ()=>{
        window.chartMode = (window.chartMode === 'radar') ? 'bar' : 'radar';
        try{ localStorage.setItem(CMODE, window.chartMode); }catch(e){}
        render();
        updateChartToggleLabel();
      });
      updateChartToggleLabel();
    }

    // 페이지 최초 렌더
    render();

    /* =========================================================
     *  방사형(레이더) 차트 렌더링
     * ======================================================= */

    /**
     * 레이더 차트 DOM 생성
     * @param {Array} data - 각 스탯 정보 {label,key,base,delta,final,grade}
     * @param {number} max - 레이더 최대 스케일 기준값
     * @param {Object} tooltipMap - 스탯 키별 툴팁 텍스트
     */
    function renderRadar(data, max, tooltipMap){
      const wrap=document.createElement('div');
      wrap.className='radarWrap';

      const n=data.length;
      const size=320;
      const cx=size/2, cy=size/2;
      const r=120;
      const svgNS='http://www.w3.org/2000/svg';

      const holder=document.createElement('div');
      holder.className='radar';

      const svg=document.createElementNS(svgNS,'svg');
      svg.setAttribute('viewBox',`0 0 ${size} ${size}`);

      // 배경 그리드(동심원)
      [0.25,0.5,0.75,1].forEach(p=>{
        const c=document.createElementNS(svgNS,'circle');
        c.setAttribute('cx',cx);
        c.setAttribute('cy',cy);
        c.setAttribute('r',r*p);
        c.setAttribute('fill','none');
        c.setAttribute('stroke','rgba(255,255,255,.1)');
        svg.appendChild(c)
      });

      // 각 스탯 축(중심 → 외곽선)
      data.forEach((d,i)=>{
        const ang=(-90 + i*(360/n)) * Math.PI/180;
        const x2=cx + r*Math.cos(ang);
        const y2=cy + r*Math.sin(ang);
        const ax=document.createElementNS(svgNS,'line');
        ax.setAttribute('x1',cx);
        ax.setAttribute('y1',cy);
        ax.setAttribute('x2',x2);
        ax.setAttribute('y2',y2);
        ax.setAttribute('stroke','rgba(255,255,255,.12)');
        svg.appendChild(ax);
      });

      // 실제 스탯을 나타내는 다각형
      const pts=data.map((d,i)=>{
        const ang=(-90 + i*(360/n)) * Math.PI/180;
        const rr=r * (d.final/max);
        const x=cx + rr*Math.cos(ang);
        const y=cy + rr*Math.sin(ang);
        return `${x},${y}`;
      }).join(' ');

      const poly=document.createElementNS(svgNS,'polygon');
      poly.setAttribute('points',pts);
      poly.setAttribute('fill','rgba(212,175,55,.28)');
      poly.setAttribute('stroke','rgba(212,175,55,.9)');
      poly.setAttribute('stroke-width','2');
      svg.appendChild(poly);

      holder.appendChild(svg);
      wrap.appendChild(holder);

      // 오른쪽에 간단한 레전드(최종치 / 변화량 / 등급)
      const lg=document.createElement('div');
      lg.className='legend';

      data.forEach(d=>{
        const row=document.createElement('div');
        row.innerHTML=
          `<strong>${d.label} [${d.grade}]</strong>` +
          `<div style="font-size:.8rem;color:${d.delta? (d.delta>0?'#7ce085':'#f48fb1'):'#ccc'}">` +
          `${d.final}${d.delta?` (${d.delta>0?'+':''}${d.delta})`:''}` +
          `</div>`;

        // 마우스 오버 시, 해당 스탯의 특성/숙련도/권능 기여 내역 툴팁
        if (tooltipMap && tooltipMap[d.key]){
          row.title = tooltipMap[d.key];
        }
        lg.appendChild(row);
      });

      wrap.appendChild(lg);
      return wrap;
    }
  </script>
</body>
</html>