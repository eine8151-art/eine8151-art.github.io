<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Character – 프로필</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0f0f12;
      --panel:#18181f;
      --panel2:#121219;
      --text:#E8E6E3;
      --muted:#b7b3ad;
      --gold:#d4af37;
      --gold2:#b8922b;
      --card:rgba(212,175,55,.35)
    }

    *{
      box-sizing:border-box
    }

    body{
      margin:0;
      background:radial-gradient(1000px 600px at 70% -20%,rgba(212,175,55,.18),transparent 60%),radial-gradient(800px 600px at 0% 10%,rgba(125,106,61,.16),transparent 60%),#050507;
      color:var(--text);
      font-family:'Noto Sans KR',system-ui,sans-serif
    }

    a{color:inherit;
      text-decoration:none
    }

    header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:14px 16px;
      border-bottom:1px solid rgba(255,255,255,.08)
    }

    .btn{
      padding:8px 12px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.04);
      cursor:pointer
    }

    .btn.gold{
      background:linear-gradient(180deg,var(--gold),var(--gold2));
      color:#111;border:none
    }

    .wrap{
      display:grid;
      grid-template-columns:320px 1fr 260px;
      gap:16px;
      padding:16px
    }

    .card{
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border-radius:16px;
      border:1px solid rgba(255,255,255,.06);
      padding:14px 16px
    }

    .avatar{
      width:100%;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:#111;
      object-fit:cover;
      max-height:520px
    }

    .title{
      margin:0;
      font-size:1.8rem
    }

    .sub{
      margin-top:4px;color:var(--muted);
      font-size:.95rem
    }

    .kv{
      display:flex;
      justify-content:space-between;
      margin:4px 0;
      font-size:.95rem
    }

    .kv span{
      color:var(--muted)
    }

    .stat-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin:12px 0 8px
    }

    .radarWrap{
      display:flex;
      gap:16px;
      align-items:flex-start;
      flex-wrap:wrap
    }

    .radar{
      width:340px;
      height:260px;
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      background:#0d0f14;
      display:flex;
      align-items:center;
      justify-content:center
    }

    .radar svg{
      width:92%;
      height:92%
    }

    .legend{
      display:grid;
      grid-template-columns:repeat(2,minmax(140px,1fr));
      gap:6px;
      min-width:260px
    }

    .bar{
      height:12px;
      background:#0d0f14;
      border:1px solid rgba(255,255,255,.08);
      border-radius:99px;
      overflow:hidden
    }

    .bar>span{
      display:block;
      height:100%;
      background:linear-gradient(90deg,var(--gold),var(--gold2))
    }

    .statrow{
      display:grid;
      grid-template-columns:110px minmax(0,1fr) 70px;
      align-items:center;
      gap:8px;margin:6px 0;
      font-size:.9rem
    }

    .statrow>span:first-child{
      white-space:nowrap
    }

    .delta{
      font-size:.8rem;
      text-align:right
    }

    .equip{
      margin-top:10px;
      font-size:.95rem
    }

    .equip h3{
      margin:0 0 6px;
      font-size:1rem
    }

    .equip-row{
      display:flex;
      justify-content:space-between;
      margin:3px 0
    }

    .equip-row span:first-child{
      color:var(--muted)
    }

    .timeline{
      font-size:.9rem;
      color:var(--muted);
      margin-top:8px;
      max-height:220px;
      overflow:auto
    }

    .timeline-entry{
      margin-bottom:6px
    }

    .timeline-entry strong{
      color:var(--text)
    }

    .skills{
      font-size:.9rem;
      margin-top:10px
    }

    .skills h3{
      margin:0 0 6px;
      font-size:1rem
    }

    .group{
      margin-bottom:10px
    }

    .gtitle{
      margin:0 0 4px;
      font-size:.9rem;
      color:var(--muted)
    }

    .plist{
      display:flex;
      flex-wrap:wrap;
      gap:6px
    }

    .pill{
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      padding:4px 8px;
      font-size:.8rem;
      background:rgba(255,255,255,.02)
    }

    .pill .tag{
      font-size:.75rem;color:var(--muted);
      margin-left:4px
    }

    .small{
      font-size:.9rem;color:var(--muted)
    }

    .tag{
      font-size:.8rem;color:var(--muted)
    }
    .badge{
      display:inline-block;
      min-width:26px;
      text-align:center;
      font-size:.7rem;
      border-radius:6px;
      padding:1px 6px;
      margin-left:6px;
      color:#e9e1c9
    }
    .badge[data-rank="EX"], .badge[data-rank^="S"]{background:rgba(212,175,55,.18)}
    .badge[data-rank^="A"]{background:rgba(102,187,106,.18)}
    .badge[data-rank^="B"]{background:rgba(100,181,246,.18)}
    .badge[data-rank^="C"]{background:rgba(255,202,40,.12)}
    .badge[data-rank^="D"]{background:rgba(239,83,80,.12)}
    .badge[data-rank^="F"]{background:rgba(176,190,197,.18);color:#e0e6e9}

    ul{margin:0;padding-left:18px}
  </style>
</head>
<body>
  <header>
    <strong style="font-family:'Cinzel',serif;letter-spacing:.06em">CHARACTER</strong>
    <div>
      <a class="btn" href="index.html">← 메인</a>
      <a class="btn" href="member.html">멤버 관리</a>
    </div>
  </header>

  <div class="wrap">
    <!-- LEFT: Portrait & Basic -->
    <section class="card">
      <img id="cImg" class="avatar" alt="portrait">
      <div style="margin-top:10px">
        <div class="kv"><span>역할</span><strong id="cRole">-</strong></div>
        <div class="kv"><span>소속</span><div id="cSub" class="small">-</div></div>
      </div>
    </section>

    <!-- CENTER: Stats & Skills -->
    <section class="card">
      <h2 class="title" id="cName">캐릭터</h2>
      <div class="sub" id="cNote" style="margin-bottom:8px"></div>

      <div class="stat-header"><h3 style="margin:0">스탯</h3><button id="chartToggle" class="btn">방사형 보기</button></div>
      <div id="statsBox"></div>
      <div class="small" id="statsHelp">기본치 + (특성/숙련도/권능의 ±, % 보정) = 최종치</div>

      <h3 style="margin:16px 0 8px">스킬/특성</h3>
      <div id="skillWrap" class="skills"></div>
    </section>

    <!-- RIGHT: Equip & Timeline -->
    <aside class="card">
      <div class="equip">
        <h3>장비</h3>
        <div class="equip-row"><span>장갑</span><span id="eqGlove">-</span></div>
        <div class="equip-row"><span>바지</span><span id="eqPants">-</span></div>
        <div class="equip-row"><span>셔츠</span><span id="eqShirt">-</span></div>
        <div class="equip-row"><span>신발</span><span id="eqBoots">-</span></div>
        <div class="equip-row"><span>무기</span><span id="eqWeapon">-</span></div>
      </div>

      <div class="timeline">
        <h3 style="margin:12px 0 6px;font-size:1rem">타임라인</h3>
        <div id="timelineBox"></div>
      </div>
    </aside>
  </div>

  <script>
    const STORE='members.v1', REP='representativeId', CODEX='codex.v1', CMODE='chartMode.v1';
    const TYPE_LABELS={trait:'특성', tech:'기술', magic:'마법', skill:'스킬', authority:'권능', blessing:'가호', proficiency:'숙련도'};
    const RANK_ORDER=["EX","SSS","SS","S+","S","A++","A+","A","A-","B++","B+","B","B-","C++","C+","C","C-","D++","D+","D","D-","F++","F+","F","F-"];
    const rankIndex=r=>{const i=RANK_ORDER.indexOf(r||''); return i<0?999:i};
    // 능력치 등급 스케일 (최종치 기준)
    const GRADE_SCALE=[
      {min:5000, rank:'EX'},
      {min:2000, rank:'SSS'},
      {min:600,  rank:'SS'},
      {min:580,  rank:'S+'},
      {min:400,  rank:'S'},
      {min:390,  rank:'A++'},
      {min:300,  rank:'A+'},
      {min:200,  rank:'A'},
      {min:190,  rank:'B++'},
      {min:150,  rank:'B+'},
      {min:70,   rank:'B'},
      {min:65,   rank:'C+'},
      {min:50,   rank:'C'},
      {min:45,   rank:'D+'},
      {min:20,   rank:'D'},
      {min:0,    rank:'F'}
    ];
    const gradeFor = v => { for(const g of GRADE_SCALE){ if((v||0) >= g.min) return g.rank } return 'F' };

    const $=s=>document.querySelector(s);

    function getParam(name){ const u=new URL(location.href); return u.searchParams.get(name) }
    function loadMembers(){ try{ return JSON.parse(localStorage.getItem(STORE)||'[]') }catch{ return [] } }
    function loadCodex(){ try{ return JSON.parse(localStorage.getItem(CODEX)||'[]') }catch{ return [] } }

    function pickCharacter(list){
      const byId = getParam('id');
      if(byId){
        return list.find(x=>x.id===byId) || list[0]
      }
      const rep = localStorage.getItem(REP);
      if(rep){ return list.find(x=>x.id===rep) || list[0] }
      return list[0];
    }

    function statRow(label, base, delta, maxRef, tooltip){
      const row=document.createElement('div'); row.className='statrow';
      const final = (base||0) + (delta||0);
      const grade = gradeFor(final);
      const maxVal = Math.max(1, maxRef||final, base, final, (base||0)+Math.abs(delta||0));
      const signed = delta? (delta>0?`+${delta}`:`${delta}`) : '';
      row.innerHTML = `<span>${label} [${grade}]</span>
        <div class='bar'><span style='width:${Math.min(100, (final/maxVal)*100)}%'></span></div>
        <div class='delta'>${final}${signed?` <span style='color:${delta>0?'#7ce085':'#f48fb1'}'>(${signed})</span>`:''}</div>`;

      // 스탯 이름 위에 툴팁 달기
      if (tooltip){
        const nameSpan = row.querySelector('span');
        if (nameSpan) nameSpan.title = tooltip;
      }
      return row;
    }

// 특성/숙련도/권능만 항상 스탯에 반영
const ALWAYS_ON_TYPES = new Set(['trait','proficiency','authority']);

// 이름이 같은 항목이 여러 개 있을 때
// → 같은 이름에서는 "가장 높은 등급(랭크)" 하나만 적용
// + 각 스탯에 어떤 출처가 기여했는지까지 기록
function collectSkillMods(ch){
  const names = ch.skills || [];
  const codex = loadCodex();
  const wanted = new Set((names || []).map(s => (s || '').toLowerCase()));

  const flat  = {str:0,end:0,agi:0,int:0,mana:0,luck:0};
  const pct   = {str:0,end:0,agi:0,int:0,mana:0,luck:0};

  // 출처별 기여도 기록용
  const sources = []; // {name,type,rank,tags,contrib:{str:{flat,pct}, ...}}

  // 1) 이름별로 가장 좋은(랭크가 높은) 항목 하나만 고르기
  const pickedByName = new Map();

  codex.forEach(e => {
    if (!ALWAYS_ON_TYPES.has(e.type)) return;            // 특성/숙련도/권능만
    const key = (e.name || '').toLowerCase();
    if (!wanted.has(key)) return;                        // 캐릭터가 가진 이름이 아니면 스킵

    const prev = pickedByName.get(key);
    if (!prev) {
      pickedByName.set(key, e);
    } else {
      // rankIndex가 작을수록 상위 등급
      const rNew = rankIndex(e.rank || '');
      const rOld = rankIndex(prev.rank || '');
      if (rNew < rOld) {
        pickedByName.set(key, e);
      }
    }
  });

  // 2) 선택된 항목들만 모아서 스탯 보정 합산 + 출처 기록
  pickedByName.forEach(e => {
    const m = e.mod  || {};
    const p = e.modP || {};

    const c = {}; // 이 출처가 기여한 스탯들

    function add(key, flatVal, pctVal){
      const f = +(flatVal || 0);
      const pc = +(pctVal || 0);
      if (!f && !pc) return;
      c[key] = {flat:f, pct:pc};
      flat[key] += f;
      pct[key]  += pc;
    }

    add('str',  m.str  ?? m.atk,  p.str  ?? p.atk);
    add('end',  m.end  ?? m.def,  p.end  ?? p.def);
    add('agi',  m.agi  ?? m.spd,  p.agi  ?? p.spd);
    add('int',  m.int,           p.int);
    add('mana', m.mana ?? m.hp,  p.mana ?? p.hp);
    add('luck', m.luck,          p.luck);

    if (Object.keys(c).length){
      sources.push({
        name: e.name || '',
        type: e.type || '',
        rank: e.rank || '',
        tags: e.tags || '',
        contrib: c
      });
    }
  });

  return {flat, pct, sources};
}

    function render(){
      const list = loadMembers();
      if(!list.length){ alert('멤버 데이터가 없습니다. member.html에서 캐릭터를 먼저 생성하세요.'); return; }
      const ch = pickCharacter(list);

      // Basic
      $('#cName').textContent = ch.name||'무명';
      $('#cNote').textContent = ch.note||'';
      $('#cRole').textContent = ch.role||'-';
      $('#cSub').textContent  = ch.sub||'-';
      $('#cImg').src = ch.img||'https://via.placeholder.com/420x560/1d1f26/777?text=NO+IMAGE';

      // Equip
      const eq = ch.equip||{};
      ['Glove','Pants','Shirt','Boots','Weapon'].forEach(k=>{ const el=$('#eq'+k); el.textContent = eq[k.toLowerCase()]||'-' });

      // Timeline
      const tl = ch.timeline||[];
      const tbox=$('#timelineBox'); tbox.innerHTML='';
      if(!tl.length){
        tbox.innerHTML='<div class="timeline-entry">(기록 없음)</div>';
      }else{
        tl.sort((a,b)=> (a.year||0)-(b.year||0) );
        tl.forEach(e=>{
          const div=document.createElement('div');
          div.className='timeline-entry';
          div.innerHTML = `<strong>${e.year??''}</strong> ${e.text??''}`;
          tbox.appendChild(div);
        });
      }

      // Stats
      const base = ch.stats||{};
      const mods = collectSkillMods(ch);

      const statDefs = [
        {label:'근력', key:'str'},
        {label:'내구', key:'end'},
        {label:'민첩', key:'agi'},
        {label:'지력', key:'int'},
        {label:'마나/내력', key:'mana'},
        {label:'행운', key:'luck'}
      ];

      const data = statDefs.map(({label,key:k})=>{
        const dFlat = mods.flat[k]||0;
        const dPct  = mods.pct[k]||0;
        const baseVal = base[k]||0;
        const delta = dFlat + Math.round(baseVal * (dPct/100));
        const final = baseVal + delta;
        return {label, key:k, base: baseVal, delta, final, grade: gradeFor(final)};
      });

      const maxFinal = Math.max(...data.map(d=>d.final), 1);

      // 스탯별 툴팁 텍스트 생성
      const tooltipMap = {};
      data.forEach(d=>{
        const related = (mods.sources || []).filter(s => s.contrib && s.contrib[d.key]);
        if (!related.length){
          tooltipMap[d.key] = `기본치: ${d.base}\n(이 스탯에는 현재 특성/숙련도/권능 보정이 적용되지 않습니다.)`;
          return;
        }
        const lines = [];
        lines.push(`기본치: ${d.base}`);
        related.forEach(s=>{
          const c = s.contrib[d.key];
          const typeLabel = TYPE_LABELS[s.type] || s.type || '기타';
          const rankText = s.rank ? ` [${s.rank}]` : '';
          const parts = [];
          if (c.flat){
            parts.push(`${c.flat>0?'+':''}${c.flat}`);
          }
          if (c.pct){
            parts.push(`${c.pct>0?'+':''}${c.pct}%`);
          }
          lines.push(`${typeLabel} ${s.name}${rankText}: ${parts.join(', ')}`);
        });
        tooltipMap[d.key] = lines.join('\n');
      });

      // Render chart
      const box=$('#statsBox'); box.innerHTML='';
      if(window.chartMode==='radar'){
        box.appendChild(renderRadar(data, maxFinal, tooltipMap));
      }else{
        data.forEach(d=> box.appendChild(
          statRow(d.label, d.base, d.delta, maxFinal, tooltipMap[d.key])
        ));
      }

      // Skills list grouped
      const codex = loadCodex();
      const byName = new Map(codex.map(x=>[((x.name||'')+'').toLowerCase(), x]));
      const skillWrap=$('#skillWrap'); skillWrap.innerHTML='';

      const sections=[
        {title:'특성', types:['trait']},
        {title:'숙련도', types:['proficiency']},
        {title:'기술/마법/스킬', types:['tech','magic','skill']},
        {title:'가호/권능', types:['blessing','authority']}
      ];

      // Prepare grouped items
      const grouped = new Map(sections.map(s=>[s.title,[]]));
      (ch.skills||[]).forEach(n=>{
        const x = byName.get((n||'').toLowerCase());
        if(!x){ // 미등록 항목은 기술/마법/스킬 그룹으로 임시 분류
          (grouped.get('기술/마법/스킬')||[]).push({name:n});
          return;
        }
        const sec = sections.find(s=> s.types.includes(x.type));
        const key = sec? sec.title : '기술/마법/스킬';
        (grouped.get(key)||[]).push(x);
      });

      // Render
      sections.forEach(sec=>{
        const arr = grouped.get(sec.title)||[];
        if(!arr.length) return;
        const box=document.createElement('div'); box.className='group';
        box.innerHTML = `<h4 class='gtitle'>${sec.title}</h4><div class='plist'></div>`;
        const plist=box.querySelector('.plist');
        arr.forEach(x=>{
          const pill=document.createElement('span'); pill.className='pill';
          if(x.type){
            pill.innerHTML = `<span>${x.name}${x.rank?` <span class="badge" data-rank="${x.rank}">${x.rank}</span>`:''}</span><span class="tag">${TYPE_LABELS[x.type]||x.type}${x.tags?` · ${x.tags}`:''}</span>`;
          } else {
            pill.textContent = x.name||'';
          }
          plist.appendChild(pill);
        });
        skillWrap.appendChild(box);
      });
    };

    // 차트 모드 초기값 및 토글 버튼 설정
    try{
      window.chartMode = localStorage.getItem(CMODE) || 'bar';
    }catch(e){
      window.chartMode = 'bar';
    }

    const chartToggleBtn = document.getElementById('chartToggle');
    function updateChartToggleLabel(){
      if(!chartToggleBtn) return;
      chartToggleBtn.textContent = (window.chartMode === 'radar') ? '막대형 보기' : '방사형 보기';
    }
    if(chartToggleBtn){
      chartToggleBtn.addEventListener('click', ()=>{
        window.chartMode = (window.chartMode === 'radar') ? 'bar' : 'radar';
        try{ localStorage.setItem(CMODE, window.chartMode); }catch(e){}
        render();
        updateChartToggleLabel();
      });
      updateChartToggleLabel();
    }

    render();

    function renderRadar(data, max, tooltipMap){
      const wrap=document.createElement('div');
      wrap.className='radarWrap';
      const n=data.length;
      const size=320;
      const cx=size/2, cy=size/2;
      const r=120;
      const svgNS='http://www.w3.org/2000/svg';
      const holder=document.createElement('div');
      holder.className='radar';
      const svg=document.createElementNS(svgNS,'svg');
      svg.setAttribute('viewBox',`0 0 ${size} ${size}`);
      // grid circles
      [0.25,0.5,0.75,1].forEach(p=>{ const c=document.createElementNS(svgNS,'circle'); c.setAttribute('cx',cx); c.setAttribute('cy',cy); c.setAttribute('r',r*p); c.setAttribute('fill','none'); c.setAttribute('stroke','rgba(255,255,255,.1)'); svg.appendChild(c) });
      // axes
      data.forEach((d,i)=>{ const ang=(-90 + i*(360/n)) * Math.PI/180; const x2=cx + r*Math.cos(ang); const y2=cy + r*Math.sin(ang); const ax=document.createElementNS(svgNS,'line'); ax.setAttribute('x1',cx); ax.setAttribute('y1',cy); ax.setAttribute('x2',x2); ax.setAttribute('y2',y2); ax.setAttribute('stroke','rgba(255,255,255,.12)'); svg.appendChild(ax); });
      // polygon
      const pts=data.map((d,i)=>{ const ang=(-90 + i*(360/n)) * Math.PI/180; const rr=r * (d.final/max); const x=cx + rr*Math.cos(ang); const y=cy + rr*Math.sin(ang); return `${x},${y}`; }).join(' ');
      const poly=document.createElementNS(svgNS,'polygon'); poly.setAttribute('points',pts); poly.setAttribute('fill','rgba(212,175,55,.28)'); poly.setAttribute('stroke','rgba(212,175,55,.9)'); poly.setAttribute('stroke-width','2'); svg.appendChild(poly);
      holder.appendChild(svg); wrap.appendChild(holder);

      // legend
      const lg=document.createElement('div'); lg.className='legend';
      data.forEach(d=>{
        const row=document.createElement('div');
        row.innerHTML=`<strong>${d.label} [${d.grade}]</strong><div style="font-size:.8rem;color:${d.delta? (d.delta>0?'#7ce085':'#f48fb1'):'#ccc'}">${d.final}${d.delta?` (${d.delta>0?'+':''}${d.delta})`:''}</div>`;
        if (tooltipMap && tooltipMap[d.key]){
          row.title = tooltipMap[d.key];
        }
        lg.appendChild(row);
      });
      wrap.appendChild(lg);
      return wrap;
    }
  </script>
</body>
</html>
